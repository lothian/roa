#Parameters:
mywfn = 'cc2'
mybasis = '6-31+G*'
cfourBasis = mybasis
cfourSpecialBasis = True
# Cartesian displacement size for optical tensor derivatives.
myresponse_disp_size = 0.005
ROAnThreads = 4
# Electric field displacement size and number of points for file17.
f17_pts = 3
f17_size = 0.001
# Hessian finite differences
hessian_points = 3
hessian_disp_size = 0.005
import subprocess
import os
rootDir = os.getcwd()
memory 4 GB
memoryCFOUR = 15

hessian_program = 'cfour'

if hessian_program == 'cfour':
    import cfour
import qcelemental as qcel

# A. Geometry from psi4
molecule mol {
  0 1
  O    1.385463243608     0.109597505732    -0.059471903413
  O   -1.385463243608    -0.109597505732    -0.059471903413
  H    1.791557065762    -1.367625723054     0.943862264704
  H   -1.791557065762     1.367625723054     0.943862264704
  units bohr
}
set {
  basis $mybasis
  scf_type pk
  r_convergence 1e-6
}
print_out("Optimizing geometry with Psi4...\n")
optimize(mywfn)

# save geometry for all computations
mol = psi4.get_active_molecule()
ROA_geom = mol.geometry().clone()
ROA_geom_np = ROA_geom.np

# B. Hessian

if hessian_program == 'cfour':
    print_out("Computing hessian with cfour...\n")
    kw = {
      'CALC'     : mywfn.upper(),
      'BASIS'    : cfourBasis.upper().replace('D-AUG','DA').replace('CC-',''),
      'VIB'      : 'EXACT',
      'UNITS'    : 'BOHR',
      'SCF_CONV' : 9,
      'MEM_UNIT' : 'GB',
      'MEMORY_SIZE' : memoryCFOUR,
      'SCF_DAMP'    : 600,
      'SCF_EXPSTART': 300,
      'SCF_MAXCYC'  : 600
    }
    xyz = ROA_geom_np
    symbols = [mol.symbol(at) for at in range(mol.natom())]
    c4 = cfour.CFOUR(xyz, symbols, kw, "opt geom from psi4")
    c4.run(cfourSpecialBasis,scratchName='roa-hessian')
    c4h = c4.parseHessian()
    # Now rotate Hessian to input orientation
    c4coord = c4.parseGeometry()
    rmsd, mill = qcel.molutil.B787(c4coord, ROA_geom_np, None, None, atoms_map=True, verbose=False)
    c4h[:] = mill.align_hessian(c4h)
    c4.writeFile15(c4h)

elif hessian_program == 'psi4':
    print_out("Computing hessian with Psi4...\n")
    set {
      basis $mybasis
      hessian_write true
      points $hessian_points
      disp_size = $hessian_disp_size
      d_convergence = 12
      scf_type = pk
    }
    mol = psi4.get_active_molecule()
    mol.set_geometry(ROA_geom)
    mol.fix_orientation(True)
    mol.fix_com(True)
    psi4_hess = hessian(mywfn)
    npHess = psi4_hess.clone().np
    npHess = np.reshape(npHess, (3*mol.natom()*mol.natom(),3))
    f = open('file15.dat', 'w')
    for i in range(npHess.shape[0]):
      f.write('{0:20.10f}{1:20.10f}{2:20.10f}\n'.format(npHess[i][0],npHess[i][1],npHess[i][2]))
    f.close()

else:
    raise("how to compute hessian?")

# C. Dipole-moment derivatives (for IR intensities).
if hessian_program == 'cfour':
    print_out("Reading dipole moment derivatives from CFOUR's DIPDER\n")
    kw = {
      'CALC'     : mywfn.upper(),
      'BASIS'    : cfourBasis.replace('cc-','').upper(),
      'VIB'      : 'EXACT',
      'UNITS'    : 'BOHR',
      'SCF_CONV' : 9,
      'MEM_UNIT' : 'GB',
      'MEMORY_SIZE' : memoryCFOUR,
      'SCF_DAMP'    : 500,
      'SCF_EXPSTART': 200,
      'SCF_MAXCYC'  : 500
    }
    xyz = ROA_geom_np
    symbols = [mol.symbol(at) for at in range(mol.natom())]
    c4 = cfour.CFOUR(xyz, symbols, kw, "test optimization")
    (c4dipx, c4dipy, c4dipz) = c4.parseDIPDER()

    # Now rotate to input orientation
    c4coord = c4.parseGeometry()
    rmsd, mill = qcel.molutil.B787(c4coord, ROA_geom_np, None, None, atoms_map=True, verbose=False)
    RotMat = mill.rotation

    # For each atom for field direction by nuclear direction 3x3 and transform it.
    for at in range(mol.natom()):
        DIPDERatom = np.zeros( (3,3) )
        DIPDERatom[0,:] = c4dipx[at,:]
        DIPDERatom[1,:] = c4dipy[at,:]
        DIPDERatom[2,:] = c4dipz[at,:]
        DIPDERatom[:] = np.dot( RotMat.T , np.dot(DIPDERatom, RotMat) )
        c4dipx[at][:] = DIPDERatom[0,:]
        c4dipy[at][:] = DIPDERatom[1,:]
        c4dipz[at][:] = DIPDERatom[2,:]
    c4.writeFile17(c4dipx, c4dipy, c4dipz)

elif hessian_program == 'psi4':
    print_out("Computing dipole moment derivatives with Psi4 by f.d...\n")
    set {
      basis $mybasis
      d_convergence = 12
      scf_type pk
      r_convergence 1e-5
    }
    mol = psi4.get_active_molecule()
    mol.set_geometry(ROA_geom)
    mol.fix_com(True)
    mol.fix_orientation(True)
    mol.reset_point_group('c1')
    
    if f17_pts == 3:
       lambdas = [-1.0*f17_size, 1.0*f17_size]
    elif f17_pts == 5:
       lambdas = [-2.0*f17_size, -1.0*f17_size, 1.0*f17_size, +2.0*f17_size]
    
    N = mol.natom()
    DmuxDx = psi4.core.Matrix("Dipole derivatives mu_x",N,3)
    DmuyDx = psi4.core.Matrix("Dipole derivatives mu_y",N,3)
    DmuzDx = psi4.core.Matrix("Dipole derivatives mu_z",N,3)
    
    for dipole_xyz, dipole_vector in enumerate([ [1,0,0],[0,1,0],[0,0,1] ]):
       dx = []
       for l in lambdas:
          set perturb_h true
          set perturb_with dipole
          scaled_dipole_vector = []
          for x in dipole_vector:
              scaled_dipole_vector.append(x*l)
          set perturb_dipole $scaled_dipole_vector
          dx.append(gradient(mywfn))
    
       for A in range(N):
          for xyz in range(3):
             if f17_pts == 3:
                val = (dx[1].get(A,xyz) - dx[0].get(A,xyz)) / (2.0*f17_size)
             elif f17_pts == 5:
                val = (dx[0].get(A,xyz) - 8.0*dx[1].get(A,xyz) \
                   + 8.0*dx[2].get(A,xyz) - dx[3].get(A,xyz)) / (12.0*f17_size)
    
             if dipole_xyz == 0:
                DmuxDx.set(A,xyz, val)
             elif dipole_xyz == 1:
                DmuyDx.set(A,xyz, val)
             elif dipole_xyz == 2:
                DmuzDx.set(A,xyz, val)

    core.set_global_option('PERTURB_H', 0)
    core.set_global_option('PERTURB_DIPOLE', '')
    
    f = open('file17.dat', 'w')
    for i in range(N):
        f.write('{0:20.10f}{1:20.10f}{2:20.10f}\n'.format(DmuxDx.get(i,0), DmuxDx.get(i,1), DmuxDx.get(i,2)))
    for i in range(N):
        f.write('{0:20.10f}{1:20.10f}{2:20.10f}\n'.format(DmuyDx.get(i,0), DmuyDx.get(i,1), DmuyDx.get(i,2)))
    for i in range(N):
        f.write('{0:20.10f}{1:20.10f}{2:20.10f}\n'.format(DmuzDx.get(i,0), DmuzDx.get(i,1), DmuzDx.get(i,2)))
    f.close()
else:
    raise("how to compute file17?")

# D. Make displacements for 3 ROA tensors.
print_out("Making displacements for ROA tensor derivatives.\n")
mol = psi4.get_active_molecule()
mol.set_geometry(ROA_geom)
mol.fix_com(True)
mol.fix_orientation(True)
mol.reset_point_group('c1')

set {
  basis $mybasis
  freeze_core true
  omega [532, nm]
  r_convergence 1e-5
}
set response_disp_size $myresponse_disp_size

properties(mywfn, properties=['roa'])

# E. Run displacements for ROA tensors
print_out("Computing ROA tensors with Psi4...\n")

dirlist = []
for A in range(1,mol.natom()+1):
  for cart in ('x','y','z'):
    for sign in ('m','p'):
      dirlist.append( "%s" % A+'_'+cart+'_'+sign )

def runRoaDisp(folder):
  print_out("Running displacement %s\n" % folder)
  rc = subprocess.call("/Users/rking/psi4/objdir/stage/bin/psi4", cwd=rootDir+'/'+folder)
  if (rc != 0): raise("Tensor calculation failed.")

import threading
nwhole = len(dirlist) // ROAnThreads
ROAthreads = []

for i in range(nwhole):
  ROAthreads.clear()
  for f in dirlist[i*ROAnThreads:(i+1)*ROAnThreads]:
    t = threading.Thread(target=runRoaDisp, args = (f,))
    ROAthreads.append(t)
    t.start()
  for th in ROAthreads:
    th.join()

for f in dirlist[nwhole*ROAnThreads:]:
  ROAthreads.clear()
  t = threading.Thread(target=runRoaDisp, args = (f,))
  ROAthreads.append(t)
  t.start()
for th in ROAthreads:
   th.join()
core.clean()

print("Starting part F. computing spectra")

# F. Calculate spectra from finite differences of tensors.
mol.set_geometry(ROA_geom)
mol.fix_orientation(True)
mol.fix_com(True)
mol.reset_point_group('c1')

set {
  basis $mybasis
  freeze_core true
  omega [532, nm]
}
set response_disp_size $myresponse_disp_size

energy(mywfn)
properties(mywfn, properties=['roa'])

